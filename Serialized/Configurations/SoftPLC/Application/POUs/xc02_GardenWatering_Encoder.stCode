PROGRAM xc02_GardenWatering_Encoder
VAR
	HorizontalAxis : Servo; (**)
	VerticalAxis : Servo; (**)
	rtHIncrement : R_TRIG; (**)
	rtHDecrement : R_TRIG; (**)
	rtVIncrement : R_TRIG; (**)
	rtVDecrement : R_TRIG; (**)
	vHorizontalS1Old : BOOL; (**)
	vHorizontalS2Old : BOOL; (**)
	vVerticalS1Old : BOOL; (**)
	vVerticalS2Old : BOOL; (**)
	PositionCounterVerticalAxis : CTUD; (**)
	vHorizontalPos : DINT; (**)
	PositionCounterHorizontalAxis : CTUD; (**)
	vVerticalPos : WORD; (**)
	vPositionX : REAL; (**)
	vPositionY : REAL; (**)
	vHorizontalLimit : BOOL; (**)
	vVerticalLimit : BOOL; (**)
	vPlatformActualPosX : REAL; (**)
	vPlatformActualPosY : REAL; (**)
END_VAR
IMPLEMENTATION
	(* The actual servos that move the watering equipment *)
	vHorizontalLimit := (vPositionX >= 940 AND NOT xgv02.HorizontalLeft)
					  OR (vPositionX <= 0 AND NOT xgv02.HorizontalRight);
	vVerticalLimit := (vPositionY >= 500 AND NOT xgv02.VerticalUp)
				    OR (vPositionY <= 0 AND NOT xgv02.VerticalDown);
	
	(* Maximum range - 940 steps *)
	HorizontalAxis(
		CmdFwd:= xgv02.HorizontalRight AND NOT vHorizontalLimit, 
		CmdRev:= xgv02.HorizontalLeft AND NOT vHorizontalLimit, 
		PulseWidth:= T#0.1S , 
		S1=> xgv02.HorizontalS1, 
		S2=> xgv02.HorizontalS2);
		
	(* Maximum range - 500 steps *)	
	VerticalAxis(
		CmdFwd:= xgv02.VerticalDown AND NOT vVerticalLimit, 
		CmdRev:= xgv02.VerticalUp AND NOT vVerticalLimit, 
		PulseWidth:= T#0.1S , 
		S1=> xgv02.VerticalS1, 
		S2=> xgv02.VerticalS2);
	
	IF xgv02.HorizontalS1 <> vHorizontalS1Old THEN
		IF xgv02.HorizontalS1 <> xgv02.HorizontalS2 THEN
			rtHIncrement(CLK:=TRUE);
		ELSE
			rtHDecrement(CLK:=TRUE);
		END_IF
	ELSE
		rtHIncrement(CLK:=FALSE);
		rtHDecrement(CLK:=FALSE);
	END_IF
	
	IF xgv02.VerticalS1 <> vVerticalS1Old THEN
		IF xgv02.VerticalS1 <> xgv02.VerticalS2 THEN
			rtVIncrement(CLK:=TRUE);
		ELSE
			rtVDecrement(CLK:=TRUE);
		END_IF
	ELSE
		rtVIncrement(CLK:=FALSE);
		rtVDecrement(CLK:=FALSE);
	END_IF
	
	PositionCounterHorizontalAxis(
		CU:= rtHIncrement.Q, 
		CD:= rtHDecrement.Q, 
		CV=> vHorizontalPos);
	
	PositionCounterVerticalAxis(
		CU:= rtVIncrement.Q, 
		CD:= rtVDecrement.Q, 
		CV=> vVerticalPos);
		
	(* Position of the system in the graphics*)
	(* For every 1 pulses we move 5 px *)
	vPositionX := (DINT_TO_REAL(vHorizontalPos)/ 1) * 5;
	vPositionY := (DINT_TO_REAL(vVerticalPos)/ 1) * 5;
		
	vHorizontalS1Old := xgv02.HorizontalS1;
	vVerticalS1Old := xgv02.VerticalS1;
	(* This is to counter the starting offset in the graphics *)
	vPlatformActualPosX := 307 + vPositionX;
	vPlatformActualPosY := 279 + vPositionY;
	
	(* Send the platform position to other programs *)
	xgv02.PositionX := vPlatformActualPosX;
	xgv02.PositionY := vPlatformActualPosY;

END_IMPLEMENTATION